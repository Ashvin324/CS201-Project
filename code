#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

enum COLOR {Red, Black};

typedef struct Node
{
int data;
struct Node *right;
struct Node *left;
struct Node *parent;
enum COLOR color;
}Node;

typedef struct RBtree
{
Node *root;
Node *NIL;
}RBtree;

Node* newNode(int data)
{
Node* n = malloc(sizeof(Node));
n->left = NULL;
n->right = NULL;
n->parent = NULL;
n->data = data;
n->color = Red;
return n;
}

RBtree* new_RBtree()
{
RBtree *t = malloc(sizeof(RBtree));
Node *nil_node = malloc(sizeof(Node));
nil_node->left = NULL;
nil_node->right = NULL;
nil_node->parent = NULL;
nil_node->color = Black;
nil_node->data = 0;
t->NIL = nil_node;
t->root = t->NIL;

return t;
}

void RB_LeftRotate(RBtree *t, Node *x) {
Node *y = x->right;
x->right = y->left;
if(y->left != t->NIL)
    y->left->parent = x;
y->parent = x->parent;
if(x->parent == t->NIL) //x is root
    t->root = y;
else if(x == x->parent->left) //x is left child
    x->parent->left = y;
else //x is right child
    x->parent->right = y;
y->left = x;
x->parent = y;
}

void RB_RightRotate(RBtree *t, Node *x)
{
Node *y = x->left;
x->left = y->right;
if(y->right != t->NIL)
    y->right->parent = x;
y->parent = x->parent;
if(x->parent == t->NIL) //x is root
    t->root = y;
else if(x == x->parent->right) //x is left child
    x->parent->right = y;
else //x is right child
    x->parent->left = y;
y->right = x;
x->parent = y;
}

struct Node* RB_Search(RBtree *t,Node *x,int val)
{
    if(val<x->data&&x->left!=t->NIL)
        RB_Search(t,x->left,val);
    else if(val>x->data&&x->right!=t->NIL)
        RB_Search(t,x->right,val);
    else if(val==x->data)
        return x;
    else
        return t->NIL;
}

void RB_InsertFix(RBtree *t, Node *z)
{
while(z->parent->color == Red)
    {
    if(z->parent == z->parent->parent->left) //z.parent is the left child
    {
    Node *y = z->parent->parent->right; //Uncle of z
    if(y->color == Red) //case 1
        {
        z->parent->color = Black;
        y->color = Black;
        z->parent->parent->color = Red;
        z = z->parent->parent;
        }
    else //case2 or case3
        {
        if(z == z->parent->right) //case2
        {
        z = z->parent;
        RB_LeftRotate(t, z);
        }
        //case3
        z->parent->color = Black;
        z->parent->parent->color = Red;
        RB_RightRotate(t, z->parent->parent);
    }
  }
  else //z.parent is the right child
    {
    Node *y = z->parent->parent->left; //Uncle of z
    if(y->color == Red)
        {
        z->parent->color = Black;
        y->color = Black;
        z->parent->parent->color = Red;
        z = z->parent->parent;
        }
    else
        {
        if(z == z->parent->left)
        {
        z = z->parent;
        RB_RightRotate(t, z);
        }
        z->parent->color = Black;
        z->parent->parent->color = Red;
        RB_LeftRotate(t, z->parent->parent);
    }
  }
}
t->root->color = Black;
}

void RB_Insert(RBtree *t, Node *z)
{
Node* y = t->NIL;
Node* ptr = t->root;
while(ptr != t->NIL)
{
  y = ptr;
  if(z->data < ptr->data)
    ptr = ptr->left;
  else
    ptr = ptr->right;
}
z->parent = y;
if(y == t->NIL) //newly added node is root
    t->root = z;
else if(z->data < y->data) //data of child is less than its parent, left child
    y->left = z;
else
    y->right = z;
z->right = t->NIL;
z->left = t->NIL;
RB_InsertFix(t, z); // Balancing tree after insertion of node
}

void RB_Transplant(RBtree *t, Node *u, Node *v)
{
if(u->parent == t->NIL)
    t->root = v;
else if(u == u->parent->left)
    u->parent->left = v;
else
    u->parent->right = v;
v->parent = u->parent;
}

Node* RB_Minimum(RBtree *t, Node *x)
{
while(x->left != t->NIL)
    x = x->left;
return x;
}

void RB_DeleteFix(RBtree *t, Node *x)
{
while(x != t->root && x->color == Black)
    {
    if(x == x->parent->left)
        {
        Node *w = x->parent->right;
        if(w->color == Red)
            {
            w->color = Black;
            x->parent->color = Red;
            RB_LeftRotate(t, x->parent);
            w = x->parent->right;
            }
        if(w->left->color == Black && w->right->color == Black)
            {
            w->color = Red;
            x = x->parent;
            }
        else
            {
            if(w->right->color == Black)
                {
                w->left->color = Black;
                w->color = Red;
                RB_RightRotate(t, w);
                w = x->parent->right;
                }
            w->color = x->parent->color;
            x->parent->color = Black;
            w->right->color = Black;
            RB_LeftRotate(t, x->parent);
            x = t->root;
            }
        }
    else
        {
        Node *w = x->parent->left;
        if(w->color == Red)
            {
            w->color = Black;
            x->parent->color = Red;
            RB_RightRotate(t, x->parent);
            w = x->parent->left;
            }
        if(w->right->color == Black && w->left->color == Black)
            {
            w->color = Red;
            x = x->parent;
            }
    else
            {
            if(w->left->color == Black)
                {
                w->right->color = Black;
                w->color = Red;
                RB_LeftRotate(t, w);
                w = x->parent->left;
                }
            w->color = x->parent->color;
            x->parent->color = Black;
            w->left->color = Black;
            RB_RightRotate(t, x->parent);
            x = t->root;
            }
        }
    }
x->color = Black;
}

void RB_Delete(RBtree *t, int val)
{
Node *z=RB_Search(t,t->root,val);
Node *y = z;
Node *x;
enum COLOR color = y->color;
if(z->left == t->NIL)
{
  x = z->right;
  RB_Transplant(t, z, z->right);
}
else if(z->right == t->NIL)
{
  x = z->left;
  RB_Transplant(t, z, z->left);
}
else
{
  y = RB_Minimum(t, z->right);
  color = y->color;
  x = y->right;
  if(y->parent == z)
    x->parent = z;
  else
  {
    RB_Transplant(t, y, y->right);
    y->right = z->right;
    y->right->parent = y;
  }
  RB_Transplant(t, z, y);
  y->left = z->left;
  y->left->parent = y;
  y->color = z->color;
}
if(color == Black)
  RB_DeleteFix(t, x);
}

void RB_Inorder(RBtree *t, Node *x)
{
if(x != t->NIL)
{
  RB_Inorder(t, x->left);
  printf("%d\n", x->data);
  RB_Inorder(t, x->right);
}
}

int main()
{
RBtree *t = new_RBtree();
char ch='Y';
    while(ch=='Y')
    {
        int choice,n,ele;
        printf("Enter your choice:\n1. Insert new elements\n2. Delete an element\n3. Search for an element\n4. Inorder Traversal of RB tree\n5. Exit\n");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1: printf("Enter number of elements to be inserted: ");
                    scanf("%d",&n);
                    printf("Enter elements to be inserted: ");
                    for(int i=0;i<n;i++)
                    {
                        scanf("%d",&ele);
                        struct Node *ptr=newNode(ele); // Creates a new node
                        RB_Insert(t,ptr); // Inserting new node
                    }
                    break;
            case 2: printf("Enter element to be deleted: ");
                    scanf("%d",&ele);
                    RB_Delete(t,ele);
                    break;
            case 3: printf("Enter element to be searched for: ");
                    scanf("%d",&ele);
                    Node *ptr=RB_Search(t,t->root,ele);
                    if(ptr!=t->NIL)
                        printf("Element found!\n");
                    else
                        printf("Element not found!\n");
                    break;
            case 4: printf("In-order traversal of RB tree:\n");
                    RB_Inorder(t,t->root);
                    break;
            case 5: printf("\nExiting...");
                    exit(0);
            default:printf("Invalid choice!\n");
                    break;
        }
        printf("\nWant to do more operations?(y or Y for yes/ any other character for no): ");
        scanf(" %c",&ch);
        ch=toupper(ch);
    }
    printf("\nExiting...");
return 0;
}
